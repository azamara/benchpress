import { ListWrapper } from 'angular2/src/facade/collection';
import { bind, provide, OpaqueToken } from 'angular2/src/core/di';
import { Validator } from '../validator';
import { Statistic } from '../statistic';
/**
 * A validator that checks the regression slope of a specific metric.
 * Waits for the regression slope to be >=0.
 */
export class RegressionSlopeValidator extends Validator {
    constructor(sampleSize, metric) {
        super();
        this._sampleSize = sampleSize;
        this._metric = metric;
    }
    // TODO(tbosch): use static values when our transpiler supports them
    static get SAMPLE_SIZE() { return _SAMPLE_SIZE; }
    // TODO(tbosch): use static values when our transpiler supports them
    static get METRIC() { return _METRIC; }
    // TODO(tbosch): use static values when our transpiler supports them
    static get BINDINGS() { return _PROVIDERS; }
    describe() {
        return { 'sampleSize': this._sampleSize, 'regressionSlopeMetric': this._metric };
    }
    validate(completeSample) {
        if (completeSample.length >= this._sampleSize) {
            var latestSample = ListWrapper.slice(completeSample, completeSample.length - this._sampleSize, completeSample.length);
            var xValues = [];
            var yValues = [];
            for (var i = 0; i < latestSample.length; i++) {
                // For now, we only use the array index as x value.
                // TODO(tbosch): think about whether we should use time here instead
                xValues.push(i);
                yValues.push(latestSample[i].values[this._metric]);
            }
            var regressionSlope = Statistic.calculateRegressionSlope(xValues, Statistic.calculateMean(xValues), yValues, Statistic.calculateMean(yValues));
            return regressionSlope >= 0 ? latestSample : null;
        }
        else {
            return null;
        }
    }
}
var _SAMPLE_SIZE = new OpaqueToken('RegressionSlopeValidator.sampleSize');
var _METRIC = new OpaqueToken('RegressionSlopeValidator.metric');
var _PROVIDERS = [
    bind(RegressionSlopeValidator)
        .toFactory((sampleSize, metric) => new RegressionSlopeValidator(sampleSize, metric), [_SAMPLE_SIZE, _METRIC]),
    provide(_SAMPLE_SIZE, { useValue: 10 }),
    provide(_METRIC, { useValue: 'scriptTime' })
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVncmVzc2lvbl9zbG9wZV92YWxpZGF0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJiZW5jaHByZXNzL3NyYy92YWxpZGF0b3IvcmVncmVzc2lvbl9zbG9wZV92YWxpZGF0b3IudHMiXSwibmFtZXMiOlsiUmVncmVzc2lvblNsb3BlVmFsaWRhdG9yIiwiUmVncmVzc2lvblNsb3BlVmFsaWRhdG9yLmNvbnN0cnVjdG9yIiwiUmVncmVzc2lvblNsb3BlVmFsaWRhdG9yLlNBTVBMRV9TSVpFIiwiUmVncmVzc2lvblNsb3BlVmFsaWRhdG9yLk1FVFJJQyIsIlJlZ3Jlc3Npb25TbG9wZVZhbGlkYXRvci5CSU5ESU5HUyIsIlJlZ3Jlc3Npb25TbG9wZVZhbGlkYXRvci5kZXNjcmliZSIsIlJlZ3Jlc3Npb25TbG9wZVZhbGlkYXRvci52YWxpZGF0ZSJdLCJtYXBwaW5ncyI6Ik9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxnQ0FBZ0M7T0FDbkQsRUFBQyxJQUFJLEVBQUUsT0FBTyxFQUFZLFdBQVcsRUFBQyxNQUFNLHNCQUFzQjtPQUVsRSxFQUFDLFNBQVMsRUFBQyxNQUFNLGNBQWM7T0FDL0IsRUFBQyxTQUFTLEVBQUMsTUFBTSxjQUFjO0FBR3RDOzs7R0FHRztBQUNILDhDQUE4QyxTQUFTO0lBV3JEQSxZQUFZQSxVQUFVQSxFQUFFQSxNQUFNQTtRQUM1QkMsT0FBT0EsQ0FBQ0E7UUFDUkEsSUFBSUEsQ0FBQ0EsV0FBV0EsR0FBR0EsVUFBVUEsQ0FBQ0E7UUFDOUJBLElBQUlBLENBQUNBLE9BQU9BLEdBQUdBLE1BQU1BLENBQUNBO0lBQ3hCQSxDQUFDQTtJQWRERCxvRUFBb0VBO0lBQ3BFQSxXQUFXQSxXQUFXQSxLQUFrQkUsTUFBTUEsQ0FBQ0EsWUFBWUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7SUFDOURGLG9FQUFvRUE7SUFDcEVBLFdBQVdBLE1BQU1BLEtBQWtCRyxNQUFNQSxDQUFDQSxPQUFPQSxDQUFDQSxDQUFDQSxDQUFDQTtJQUNwREgsb0VBQW9FQTtJQUNwRUEsV0FBV0EsUUFBUUEsS0FBaUJJLE1BQU1BLENBQUNBLFVBQVVBLENBQUNBLENBQUNBLENBQUNBO0lBV3hESixRQUFRQTtRQUNOSyxNQUFNQSxDQUFDQSxFQUFDQSxZQUFZQSxFQUFFQSxJQUFJQSxDQUFDQSxXQUFXQSxFQUFFQSx1QkFBdUJBLEVBQUVBLElBQUlBLENBQUNBLE9BQU9BLEVBQUNBLENBQUNBO0lBQ2pGQSxDQUFDQTtJQUVETCxRQUFRQSxDQUFDQSxjQUErQkE7UUFDdENNLEVBQUVBLENBQUNBLENBQUNBLGNBQWNBLENBQUNBLE1BQU1BLElBQUlBLElBQUlBLENBQUNBLFdBQVdBLENBQUNBLENBQUNBLENBQUNBO1lBQzlDQSxJQUFJQSxZQUFZQSxHQUFHQSxXQUFXQSxDQUFDQSxLQUFLQSxDQUFDQSxjQUFjQSxFQUFFQSxjQUFjQSxDQUFDQSxNQUFNQSxHQUFHQSxJQUFJQSxDQUFDQSxXQUFXQSxFQUN4REEsY0FBY0EsQ0FBQ0EsTUFBTUEsQ0FBQ0EsQ0FBQ0E7WUFDNURBLElBQUlBLE9BQU9BLEdBQUdBLEVBQUVBLENBQUNBO1lBQ2pCQSxJQUFJQSxPQUFPQSxHQUFHQSxFQUFFQSxDQUFDQTtZQUNqQkEsR0FBR0EsQ0FBQ0EsQ0FBQ0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsR0FBR0EsQ0FBQ0EsRUFBRUEsQ0FBQ0EsR0FBR0EsWUFBWUEsQ0FBQ0EsTUFBTUEsRUFBRUEsQ0FBQ0EsRUFBRUEsRUFBRUEsQ0FBQ0E7Z0JBQzdDQSxtREFBbURBO2dCQUNuREEsb0VBQW9FQTtnQkFDcEVBLE9BQU9BLENBQUNBLElBQUlBLENBQUNBLENBQUNBLENBQUNBLENBQUNBO2dCQUNoQkEsT0FBT0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsWUFBWUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsTUFBTUEsQ0FBQ0EsSUFBSUEsQ0FBQ0EsT0FBT0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7WUFDckRBLENBQUNBO1lBQ0RBLElBQUlBLGVBQWVBLEdBQUdBLFNBQVNBLENBQUNBLHdCQUF3QkEsQ0FDcERBLE9BQU9BLEVBQUVBLFNBQVNBLENBQUNBLGFBQWFBLENBQUNBLE9BQU9BLENBQUNBLEVBQUVBLE9BQU9BLEVBQUVBLFNBQVNBLENBQUNBLGFBQWFBLENBQUNBLE9BQU9BLENBQUNBLENBQUNBLENBQUNBO1lBQzFGQSxNQUFNQSxDQUFDQSxlQUFlQSxJQUFJQSxDQUFDQSxHQUFHQSxZQUFZQSxHQUFHQSxJQUFJQSxDQUFDQTtRQUNwREEsQ0FBQ0E7UUFBQ0EsSUFBSUEsQ0FBQ0EsQ0FBQ0E7WUFDTkEsTUFBTUEsQ0FBQ0EsSUFBSUEsQ0FBQ0E7UUFDZEEsQ0FBQ0E7SUFDSEEsQ0FBQ0E7QUFDSE4sQ0FBQ0E7QUFFRCxJQUFJLFlBQVksR0FBRyxJQUFJLFdBQVcsQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO0FBQzFFLElBQUksT0FBTyxHQUFHLElBQUksV0FBVyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7QUFDakUsSUFBSSxVQUFVLEdBQUc7SUFDZixJQUFJLENBQUMsd0JBQXdCLENBQUM7U0FDekIsU0FBUyxDQUFDLENBQUMsVUFBVSxFQUFFLE1BQU0sS0FBSyxJQUFJLHdCQUF3QixDQUFDLFVBQVUsRUFBRSxNQUFNLENBQUMsRUFDeEUsQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDdkMsT0FBTyxDQUFDLFlBQVksRUFBRSxFQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUMsQ0FBQztJQUNyQyxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUMsUUFBUSxFQUFFLFlBQVksRUFBQyxDQUFDO0NBQzNDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0xpc3RXcmFwcGVyfSBmcm9tICdhbmd1bGFyMi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nO1xuaW1wb3J0IHtiaW5kLCBwcm92aWRlLCBQcm92aWRlciwgT3BhcXVlVG9rZW59IGZyb20gJ2FuZ3VsYXIyL3NyYy9jb3JlL2RpJztcblxuaW1wb3J0IHtWYWxpZGF0b3J9IGZyb20gJy4uL3ZhbGlkYXRvcic7XG5pbXBvcnQge1N0YXRpc3RpY30gZnJvbSAnLi4vc3RhdGlzdGljJztcbmltcG9ydCB7TWVhc3VyZVZhbHVlc30gZnJvbSAnLi4vbWVhc3VyZV92YWx1ZXMnO1xuXG4vKipcbiAqIEEgdmFsaWRhdG9yIHRoYXQgY2hlY2tzIHRoZSByZWdyZXNzaW9uIHNsb3BlIG9mIGEgc3BlY2lmaWMgbWV0cmljLlxuICogV2FpdHMgZm9yIHRoZSByZWdyZXNzaW9uIHNsb3BlIHRvIGJlID49MC5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlZ3Jlc3Npb25TbG9wZVZhbGlkYXRvciBleHRlbmRzIFZhbGlkYXRvciB7XG4gIC8vIFRPRE8odGJvc2NoKTogdXNlIHN0YXRpYyB2YWx1ZXMgd2hlbiBvdXIgdHJhbnNwaWxlciBzdXBwb3J0cyB0aGVtXG4gIHN0YXRpYyBnZXQgU0FNUExFX1NJWkUoKTogT3BhcXVlVG9rZW4geyByZXR1cm4gX1NBTVBMRV9TSVpFOyB9XG4gIC8vIFRPRE8odGJvc2NoKTogdXNlIHN0YXRpYyB2YWx1ZXMgd2hlbiBvdXIgdHJhbnNwaWxlciBzdXBwb3J0cyB0aGVtXG4gIHN0YXRpYyBnZXQgTUVUUklDKCk6IE9wYXF1ZVRva2VuIHsgcmV0dXJuIF9NRVRSSUM7IH1cbiAgLy8gVE9ETyh0Ym9zY2gpOiB1c2Ugc3RhdGljIHZhbHVlcyB3aGVuIG91ciB0cmFuc3BpbGVyIHN1cHBvcnRzIHRoZW1cbiAgc3RhdGljIGdldCBCSU5ESU5HUygpOiBQcm92aWRlcltdIHsgcmV0dXJuIF9QUk9WSURFUlM7IH1cblxuICBfc2FtcGxlU2l6ZTogbnVtYmVyO1xuICBfbWV0cmljOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioc2FtcGxlU2l6ZSwgbWV0cmljKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9zYW1wbGVTaXplID0gc2FtcGxlU2l6ZTtcbiAgICB0aGlzLl9tZXRyaWMgPSBtZXRyaWM7XG4gIH1cblxuICBkZXNjcmliZSgpOiB7W2tleTogc3RyaW5nXTogYW55fSB7XG4gICAgcmV0dXJuIHsnc2FtcGxlU2l6ZSc6IHRoaXMuX3NhbXBsZVNpemUsICdyZWdyZXNzaW9uU2xvcGVNZXRyaWMnOiB0aGlzLl9tZXRyaWN9O1xuICB9XG5cbiAgdmFsaWRhdGUoY29tcGxldGVTYW1wbGU6IE1lYXN1cmVWYWx1ZXNbXSk6IE1lYXN1cmVWYWx1ZXNbXSB7XG4gICAgaWYgKGNvbXBsZXRlU2FtcGxlLmxlbmd0aCA+PSB0aGlzLl9zYW1wbGVTaXplKSB7XG4gICAgICB2YXIgbGF0ZXN0U2FtcGxlID0gTGlzdFdyYXBwZXIuc2xpY2UoY29tcGxldGVTYW1wbGUsIGNvbXBsZXRlU2FtcGxlLmxlbmd0aCAtIHRoaXMuX3NhbXBsZVNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVTYW1wbGUubGVuZ3RoKTtcbiAgICAgIHZhciB4VmFsdWVzID0gW107XG4gICAgICB2YXIgeVZhbHVlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3RTYW1wbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRm9yIG5vdywgd2Ugb25seSB1c2UgdGhlIGFycmF5IGluZGV4IGFzIHggdmFsdWUuXG4gICAgICAgIC8vIFRPRE8odGJvc2NoKTogdGhpbmsgYWJvdXQgd2hldGhlciB3ZSBzaG91bGQgdXNlIHRpbWUgaGVyZSBpbnN0ZWFkXG4gICAgICAgIHhWYWx1ZXMucHVzaChpKTtcbiAgICAgICAgeVZhbHVlcy5wdXNoKGxhdGVzdFNhbXBsZVtpXS52YWx1ZXNbdGhpcy5fbWV0cmljXSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVncmVzc2lvblNsb3BlID0gU3RhdGlzdGljLmNhbGN1bGF0ZVJlZ3Jlc3Npb25TbG9wZShcbiAgICAgICAgICB4VmFsdWVzLCBTdGF0aXN0aWMuY2FsY3VsYXRlTWVhbih4VmFsdWVzKSwgeVZhbHVlcywgU3RhdGlzdGljLmNhbGN1bGF0ZU1lYW4oeVZhbHVlcykpO1xuICAgICAgcmV0dXJuIHJlZ3Jlc3Npb25TbG9wZSA+PSAwID8gbGF0ZXN0U2FtcGxlIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG5cbnZhciBfU0FNUExFX1NJWkUgPSBuZXcgT3BhcXVlVG9rZW4oJ1JlZ3Jlc3Npb25TbG9wZVZhbGlkYXRvci5zYW1wbGVTaXplJyk7XG52YXIgX01FVFJJQyA9IG5ldyBPcGFxdWVUb2tlbignUmVncmVzc2lvblNsb3BlVmFsaWRhdG9yLm1ldHJpYycpO1xudmFyIF9QUk9WSURFUlMgPSBbXG4gIGJpbmQoUmVncmVzc2lvblNsb3BlVmFsaWRhdG9yKVxuICAgICAgLnRvRmFjdG9yeSgoc2FtcGxlU2l6ZSwgbWV0cmljKSA9PiBuZXcgUmVncmVzc2lvblNsb3BlVmFsaWRhdG9yKHNhbXBsZVNpemUsIG1ldHJpYyksXG4gICAgICAgICAgICAgICAgIFtfU0FNUExFX1NJWkUsIF9NRVRSSUNdKSxcbiAgcHJvdmlkZShfU0FNUExFX1NJWkUsIHt1c2VWYWx1ZTogMTB9KSxcbiAgcHJvdmlkZShfTUVUUklDLCB7dXNlVmFsdWU6ICdzY3JpcHRUaW1lJ30pXG5dO1xuIl19